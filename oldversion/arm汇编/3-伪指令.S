CONST1	EQU		0x50003100	; 为常量0x50003100指定名称							
CONST2	EQU		0x20		; 为常量0x20指定名称
		
		GBLL 	ValL		; 声明一个全局的逻辑变量
		GBLA 	ValA		; 声明一个全局的数字变量						
			
		AREA	start,CODE,READONLY	; 声明代码段start 
		ENTRY				; 标识程序入口
		CODE32				; 声明32位ARM指令
		;下面列出LDR和ADR的用法，注释部分给出反汇编结果和说明
START	
		;===========================================================		
		;  LDR reg, ={lab}或={num}是用于加载标号地址和立即数的伪指令，
		;不加"="号时，表示内存寻址。
		;  ADR是将基于PC相对偏移的地址值或基于寄存器相对地址值读取的
		;伪指令。  
		;===========================================================
		LDR		R0,=CONST1	; 如果看反汇编结果，会发现编译器用存放
							; COUNT的内存单元地址替换了=COUNT
		LDR		R1,=CONST2	; 由于0x20不大，伪指令被解析成了mov r1,#0x20
		ADR		R2, START	; adr r2,{pc}-4 ;用pc+offset获得标号地址			
		LDR		R3, START	; 非伪指令，获得标号地址作为内存地址的内容
		LDR		R4,=START	; 存放START标号值的地址替换了=START
		LDR		R5,=0x50200000	;存放常量的地址替换了=0x50200000
		LDR		R6,=0x10	; 由于0x10不大，伪指令被解析成了mov r6,#0x10 
		;对于以上两句指令，编译器会在RO段中为START标号的值和常量0x50200000
		;专门分配空间，如果之后再出现相同常量使用，编译器不会重新分配空间
		
		;===========================================================		
		;  MACRO 、 MEND 伪指令可以将一段代码定义为一个整体，称为宏
		;指令，然后就可以在程序中通过宏指令多次调用该段代码。
		;===========================================================		
		MACRO
		RETURN
		MOV PC,LR
		MEND
	
		;===========================================================		
		;  IF 、 ELSE 、 ENDIF 伪指令能根据条件的成立与否决定是否执
		;行某个指令序列。IF--ELSE--ENDIF 可以用[   |   ]替代方法是：
		;[ 	条件
		;	执行语句
		;|
		;	执行语句
		;]
		;===========================================================		
ValL	SETL	{TRUE}		
		
		IF		ValL = {TRUE}
ValA	SETA	0x9		;9
		BL		SUM
		LDR		R1,	=ValA	;看看这句的反汇编结果，说明什么？
		ELSE
		B		HALT				 
		ENDIF
		
		NOP
		NOP
		
HALT	B	HALT

		;===========================================================		
		;  WHILE 、 WEND 伪指令能根据条件的成立与否决定是否循环执行
		;某个指令序列。下面代码使用WHILE--WEND伪指令完成1+2+...+ValA
		;的求和。
		;===========================================================
SUM		
		MOV R0,#0
		MOV	R1,#1
		WHILE	ValA > 0
		ADD	R0,R0,R1
		ADD	R1,R1,#1		
ValA	SETA	ValA-1			
		WEND
		RETURN
		
		END	
